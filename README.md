# CS-300-Data-Structures

This repository contains selected portfolio artifacts from CS 300: Data Structures and Algorithms at Southern New Hampshire University. The projects in this repository demonstrate my ability to analyze algorithm efficiency, evaluate data structures, and implement working solutions using Java. The focus of this course was on understanding how data structures impact performance, scalability, and maintainability in software systems.

The artifacts included showcase both theoretical analysis and practical application, including run-time and memory evaluation of data structures and a fully functional program that sorts and displays course data in alphanumeric order.

Skills Demonstrated: Data Structures · Algorithms · Big-O Analysis · Java Programming · Problem Solving · Software Design

---

## Reflection Journal

The projects in CS 300 focused on solving the problem of efficiently storing, organizing, and retrieving course information. In Project One, I analyzed the run-time complexity and memory usage of different data structures, including vectors, hash tables, and binary search trees, to determine which structures were best suited for managing course data. In Project Two, I applied this analysis by implementing a working Java program that reads course data and outputs it in alphanumeric order.

One of the most important aspects of my approach was understanding the problem before selecting a solution. By comparing data structures based on worst-case performance and memory considerations, I was able to make informed decisions rather than relying on trial and error. This reinforced the importance of data structures in software development, as the choice of structure directly affects efficiency and scalability.

During the projects, I encountered challenges related to implementing correct sorting logic and understanding how algorithmic complexity applied to real code. I overcame these challenges by revisiting pseudocode, breaking the problem into smaller steps, and testing incrementally. This process helped me strengthen both my debugging skills and my confidence in working with more complex logic.

Working on these projects expanded my approach to designing software by emphasizing planning and structure before implementation. I now prioritize evaluating requirements and selecting appropriate data structures early in the development process, which leads to clearer, more efficient designs.

These projects also influenced how I write maintainable, readable, and adaptable code. I focused on using clear naming conventions, modular design, and logical organization so the code is easier to understand and extend. Understanding algorithm performance has helped me write programs that can adapt to larger datasets without significant redesign, which is an essential skill for real-world software development.

